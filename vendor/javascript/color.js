import*as t from"color-string";import*as o from"color-convert";var r="default"in t?t.default:t;var e="default"in o?o.default:o;var n="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:global;var s={};const l=r;const a=e;const h=["keyword","gray","hex"];const i={};for(const t of Object.keys(a))i[[...a[t].labels].sort().join("")]=t;const c={};function Color(t,o){if(!((this||n)instanceof Color))return new Color(t,o);o&&o in h&&(o=null);if(o&&!(o in a))throw new Error("Unknown model: "+o);let r;let e;if(null==t){(this||n).model="rgb";(this||n).color=[0,0,0];(this||n).valpha=1}else if(t instanceof Color){(this||n).model=t.model;(this||n).color=[...t.color];(this||n).valpha=t.valpha}else if("string"===typeof t){const o=l.get(t);if(null===o)throw new Error("Unable to parse color from string: "+t);(this||n).model=o.model;e=a[(this||n).model].channels;(this||n).color=o.value.slice(0,e);(this||n).valpha="number"===typeof o.value[e]?o.value[e]:1}else if(t.length>0){(this||n).model=o||"rgb";e=a[(this||n).model].channels;const r=Array.prototype.slice.call(t,0,e);(this||n).color=zeroArray(r,e);(this||n).valpha="number"===typeof t[e]?t[e]:1}else if("number"===typeof t){(this||n).model="rgb";(this||n).color=[t>>16&255,t>>8&255,255&t];(this||n).valpha=1}else{(this||n).valpha=1;const o=Object.keys(t);if("alpha"in t){o.splice(o.indexOf("alpha"),1);(this||n).valpha="number"===typeof t.alpha?t.alpha:0}const e=o.sort().join("");if(!(e in i))throw new Error("Unable to parse color from object: "+JSON.stringify(t));(this||n).model=i[e];const{labels:s}=a[(this||n).model];const l=[];for(r=0;r<s.length;r++)l.push(t[s[r]]);(this||n).color=zeroArray(l)}if(c[(this||n).model]){e=a[(this||n).model].channels;for(r=0;r<e;r++){const t=c[(this||n).model][r];t&&((this||n).color[r]=t((this||n).color[r]))}}(this||n).valpha=Math.max(0,Math.min(1,(this||n).valpha));Object.freeze&&Object.freeze(this||n)}Color.prototype={toString(){return this.string()},toJSON(){return this[(this||n).model]()},string(t){let o=(this||n).model in l.to?this||n:this.rgb();o=o.round("number"===typeof t?t:1);const r=1===o.valpha?o.color:[...o.color,(this||n).valpha];return l.to[o.model](r)},percentString(t){const o=this.rgb().round("number"===typeof t?t:1);const r=1===o.valpha?o.color:[...o.color,(this||n).valpha];return l.to.rgb.percent(r)},array(){return 1===(this||n).valpha?[...(this||n).color]:[...(this||n).color,(this||n).valpha]},object(){const t={};const{channels:o}=a[(this||n).model];const{labels:r}=a[(this||n).model];for(let e=0;e<o;e++)t[r[e]]=(this||n).color[e];1!==(this||n).valpha&&(t.alpha=(this||n).valpha);return t},unitArray(){const t=this.rgb().color;t[0]/=255;t[1]/=255;t[2]/=255;1!==(this||n).valpha&&t.push((this||n).valpha);return t},unitObject(){const t=this.rgb().object();t.r/=255;t.g/=255;t.b/=255;1!==(this||n).valpha&&(t.alpha=(this||n).valpha);return t},round(t){t=Math.max(t||0,0);return new Color([...(this||n).color.map(roundToPlace(t)),(this||n).valpha],(this||n).model)},alpha(t){return void 0!==t?new Color([...(this||n).color,Math.max(0,Math.min(1,t))],(this||n).model):(this||n).valpha},red:getset("rgb",0,maxfn(255)),green:getset("rgb",1,maxfn(255)),blue:getset("rgb",2,maxfn(255)),hue:getset(["hsl","hsv","hsl","hwb","hcg"],0,(t=>(t%360+360)%360)),saturationl:getset("hsl",1,maxfn(100)),lightness:getset("hsl",2,maxfn(100)),saturationv:getset("hsv",1,maxfn(100)),value:getset("hsv",2,maxfn(100)),chroma:getset("hcg",1,maxfn(100)),gray:getset("hcg",2,maxfn(100)),white:getset("hwb",1,maxfn(100)),wblack:getset("hwb",2,maxfn(100)),cyan:getset("cmyk",0,maxfn(100)),magenta:getset("cmyk",1,maxfn(100)),yellow:getset("cmyk",2,maxfn(100)),black:getset("cmyk",3,maxfn(100)),x:getset("xyz",0,maxfn(95.047)),y:getset("xyz",1,maxfn(100)),z:getset("xyz",2,maxfn(108.833)),l:getset("lab",0,maxfn(100)),a:getset("lab",1),b:getset("lab",2),keyword(t){return void 0!==t?new Color(t):a[(this||n).model].keyword((this||n).color)},hex(t){return void 0!==t?new Color(t):l.to.hex(this.rgb().round().color)},hexa(t){if(void 0!==t)return new Color(t);const o=this.rgb().round().color;let r=Math.round(255*(this||n).valpha).toString(16).toUpperCase();1===r.length&&(r="0"+r);return l.to.hex(o)+r},rgbNumber(){const t=this.rgb().color;return(255&t[0])<<16|(255&t[1])<<8|255&t[2]},luminosity(){const t=this.rgb().color;const o=[];for(const[r,e]of t.entries()){const t=e/255;o[r]=t<=.04045?t/12.92:((t+.055)/1.055)**2.4}return.2126*o[0]+.7152*o[1]+.0722*o[2]},contrast(t){const o=this.luminosity();const r=t.luminosity();return o>r?(o+.05)/(r+.05):(r+.05)/(o+.05)},level(t){const o=this.contrast(t);return o>=7?"AAA":o>=4.5?"AA":""},isDark(){const t=this.rgb().color;const o=(2126*t[0]+7152*t[1]+722*t[2])/1e4;return o<128},isLight(){return!this.isDark()},negate(){const t=this.rgb();for(let o=0;o<3;o++)t.color[o]=255-t.color[o];return t},lighten(t){const o=this.hsl();o.color[2]+=o.color[2]*t;return o},darken(t){const o=this.hsl();o.color[2]-=o.color[2]*t;return o},saturate(t){const o=this.hsl();o.color[1]+=o.color[1]*t;return o},desaturate(t){const o=this.hsl();o.color[1]-=o.color[1]*t;return o},whiten(t){const o=this.hwb();o.color[1]+=o.color[1]*t;return o},blacken(t){const o=this.hwb();o.color[2]+=o.color[2]*t;return o},grayscale(){const t=this.rgb().color;const o=.3*t[0]+.59*t[1]+.11*t[2];return Color.rgb(o,o,o)},fade(t){return this.alpha((this||n).valpha-(this||n).valpha*t)},opaquer(t){return this.alpha((this||n).valpha+(this||n).valpha*t)},rotate(t){const o=this.hsl();let r=o.color[0];r=(r+t)%360;r=r<0?360+r:r;o.color[0]=r;return o},mix(t,o){if(!t||!t.rgb)throw new Error('Argument to "mix" was not a Color instance, but rather an instance of '+typeof t);const r=t.rgb();const e=this.rgb();const n=void 0===o?.5:o;const s=2*n-1;const l=r.alpha()-e.alpha();const a=((s*l===-1?s:(s+l)/(1+s*l))+1)/2;const h=1-a;return Color.rgb(a*r.red()+h*e.red(),a*r.green()+h*e.green(),a*r.blue()+h*e.blue(),r.alpha()*n+e.alpha()*(1-n))}};for(const t of Object.keys(a)){if(h.includes(t))continue;const{channels:o}=a[t];Color.prototype[t]=function(...o){return(this||n).model===t?new Color(this||n):o.length>0?new Color(o,t):new Color([...assertArray(a[(this||n).model][t].raw((this||n).color)),(this||n).valpha],t)};Color[t]=function(...r){let e=r[0];"number"===typeof e&&(e=zeroArray(r,o));return new Color(e,t)}}function roundTo(t,o){return Number(t.toFixed(o))}function roundToPlace(t){return function(o){return roundTo(o,t)}}function getset(t,o,r){t=Array.isArray(t)?t:[t];for(const e of t)(c[e]||(c[e]=[]))[o]=r;t=t[0];return function(e){let n;if(void 0!==e){r&&(e=r(e));n=this[t]();n.color[o]=e;return n}n=this[t]().color[o];r&&(n=r(n));return n}}function maxfn(t){return function(o){return Math.max(0,Math.min(t,o))}}function assertArray(t){return Array.isArray(t)?t:[t]}function zeroArray(t,o){for(let r=0;r<o;r++)"number"!==typeof t[r]&&(t[r]=0);return t}s=Color;var u=s;export{u as default};

